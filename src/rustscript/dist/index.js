// Generated by RustScript compiler
// Do not edit manually

class SimpleCounterTranspiler {
  constructor() {
    this._output = [];
    this._indentLevel = 0;
  }
  
  append(s) { this._output.push(s); }
  newline() { this._output.push('\n'); }
  indent() { this._indentLevel++; }
  dedent() { this._indentLevel--; }
  toString() { return this._output.join(''); }
  
  init() {
    { current_component: None };
  }
  
  visit_function_declaration(node) {
    const component_name = (node.id ? id.name : );
    if (!component_name.chars().next().unwrap().is_uppercase()) {
      return;
    }
    let component = { name: component_name, state_fields: [], ref_fields: [], effect_methods: [], event_methods: [], render_jsx: None };
    const __iflet_2 = node.body;
    if (__iflet_2 !== null && __iflet_2 !== undefined) {
      const body = __iflet_2;
      let effect_counter = 0;
      let jsx_node = None;
      // Captures: [&mut component, &mut effect_counter, &mut jsx_node]
      const __visitor_0 = {
        VariableDeclarator(path) {
          const decl = path.node;
          const __iflet_5 = decl.init;
          if (__iflet_5 !== null && __iflet_5 !== undefined) {
            const init = __iflet_5;
            if ((t.isCallExpression(init))) {
              const call = init;
              if ((t.isIdentifier(call.callee))) {
                const callee_name = call.callee.name;
                if ((callee_name === "useState")) {
                  if ((t.isArrayPattern(decl.id))) {
                    const arr = decl.id;
                    if ((arr.elements.length >= 1)) {
                      const __iflet_11 = arr.elements[0];
                      if (__iflet_11 !== null && __iflet_11 !== undefined) {
                        const state_name = state_id.name;
                        const initial_val = ((call.arguments.length > 0) ? Self.expr_to_csharp_value(call.arguments[0]) : "null".join(""));
                        const csharp_type = ((call.arguments.length > 0) ? Self.infer_csharp_type_from_expr(call.arguments[0]) : "dynamic".join(""));
                        component.state_fields.push({ name: state_name, initial_value: initial_val, csharp_type: csharp_type });
                      }
                    }
                  }
                } else {
                  if ((callee_name === "useRef")) {
                    if ((t.isIdentifier(decl.id))) {
                      const ref_name = decl.id.name;
                      component.ref_fields.push({ name: ref_name });
                    }
                  } else {
                    if ((callee_name === "useEffect")) {
                      let deps = [];
                      if ((call.arguments.length > 1)) {
                        if ((t.isArrayExpression(call.arguments[1]))) {
                          const arr = call.arguments[1];
                          for (const elem of arr.elements) {
                            const __iflet_14 = elem;
                            if (__iflet_14 !== null && __iflet_14 !== undefined) {
                              deps.push(dep_id.name);
                            }
                          }
                        }
                      }
                      component.effect_methods.push({ index: effect_counter, dependencies: deps });
                      effect_counter += 1;
                    }
                  }
                }
              }
            }
          }
        },
        FunctionDeclaration(path) {
          const func = path.node;
          const __iflet_5 = func.id;
          if (__iflet_5 !== null && __iflet_5 !== undefined) {
            const id = __iflet_5;
            const method_name = Self.capitalize_first(id.name);
            component.event_methods.push({ name: method_name });
          }
        },
        ReturnStatement(path) {
          const ret = path.node;
          const __iflet_5 = ret.argument;
          if (__iflet_5 !== null && __iflet_5 !== undefined) {
            const arg = __iflet_5;
            if ((t.isJSXElement(arg))) {
              const jsx_elem = arg;
              jsx_node = Some(Self.extract_jsx_node(jsx_elem));
            }
          }
        },
      };
      path.get('body').traverse(__visitor_0);
      component = { name: component.name, state_fields: component.state_fields, ref_fields: component.ref_fields, effect_methods: component.effect_methods, event_methods: component.event_methods, render_jsx: jsx_node };
    }
    this = { current_component: Some(component) };
  }
  
  capitalize_first(s) {
    let chars = s.chars();
    if (chars.next() === null || chars.next() === undefined) {
      "";
    } else if (chars.next() !== null && chars.next() !== undefined) {
      first.toUpperCase().chain(chars).collect();
    }
  }
  
  expr_to_csharp_value(expr) {
    if (expr !== null) {
      n.value.join("");
    } else if (expr !== null) {
      `"${s.value}"`;
    } else if (expr !== null) {
      (b.value ? "true".join("") : "false".join(""));
    } else if (expr !== null) {
      "null".join("");
    } else if (expr !== null) {
      id.name;
    } else if (true) {
      "null".join("");
    }
  }
  
  infer_csharp_type_from_expr(expr) {
    if (expr !== null) {
      (() => {
        if ((n.value === n.value.floor())) {
          "int".join("");
        } else {
          "double".join("");
        }
      })();
    } else if (expr !== null) {
      "string".join("");
    } else if (expr !== null) {
      "bool".join("");
    } else if (expr !== null) {
      "List<dynamic>".join("");
    } else if (expr !== null) {
      "Dictionary<string, dynamic>".join("");
    } else if (true) {
      "dynamic".join("");
    }
  }
  
  extract_jsx_node(jsx) {
    const tag = (() => { if (jsx.opening_element.name !== null) { return id.name; } else if (true) { return "div".join(""); } })();
    let attributes = [];
    for (const attr of jsx.opening_element.attributes) {
      if ((t.isJSXAttribute(attr))) {
        const attr_name = (() => { if (attr.name !== null) { return id.name; } else if (true) { return continue; } })();
        const attr_value = (attr.value ?  : "true".join(""));
        attributes.push({ name: attr_name, value: attr_value });
      }
    }
    let children = [];
    for (const child of jsx.children) {
      if (child !== null) {
        (() => {
          children.push(JSXChild.Element(Self.extract_jsx_node(elem)));
        })();
      } else if (child !== null) {
        (() => {
          const trimmed = text.value.trim();
          if (!(trimmed.length === 0)) {
            children.push(JSXChild.Text(trimmed.join("")));
          }
        })();
      } else if (child !== null) {
        (() => {
          if ((t.isExpression(container.expression))) {
            const expr = container.expression;
            const expr_str = Self.expr_to_csharp_value(expr);
            children.push(JSXChild.Expression(expr_str));
          }
        })();
      } else if (true) {
        (() => {
        })();
      }
    }
    { tag: tag, attributes: attributes, children: children };
  }
  
  jsx_node_to_vnode_code(node) {
    let attrs_code = [];
    for (const attr of node.attributes) {
      const value_code = (attr.value.startsWith("{expr:") ? attr.value.trim_start_matches("{expr:").trim_end_matches("}").join("") : `"${attr.value}"`);
      attrs_code.push(`                ["${attr.name}"] = ${value_code}`);
    }
    let children_code = [];
    for (const child of node.children) {
      if (child !== null) {
        (() => {
          children_code.push(Self.jsx_node_to_vnode_code(elem));
        })();
      } else if (child !== null) {
        (() => {
          children_code.push(`"${text}"`);
        })();
      } else if (child !== null) {
        (() => {
          children_code.push(`\$"{${expr}}"`);
        })();
      }
    }
    let result = `new VElement("${node.tag}", `;
    if (((attrs_code.length === 0) && (children_code.length === 0))) {
      result += "null, null)";
    } else {
      if ((attrs_code.length === 0)) {
        result += "null, ";
        if ((children_code.length === 1)) {
          result += children_code[0];
        } else {
          result += "new VNode[]\n            {\n                ";
          result += children_code.join(",\n                ");
          result += "\n            }";
        }
        result.push(")");
      } else {
        result += "new Dictionary<string, string>\n            {\n";
        result += attrs_code.join(",\n");
        result += "\n            }, ";
        if ((children_code.length === 0)) {
          result += "null";
        } else {
          if ((children_code.length === 1)) {
            result += children_code[0];
          } else {
            result += "new VNode[]\n            {\n                ";
            result += children_code.join(",\n                ");
            result += "\n            }";
          }
        }
        result.push(")");
      }
    }
    result;
  }
  
  finish(self) {
    let lines = [];
    const __iflet_2 = this.current_component;
    if (__iflet_2 !== null && __iflet_2 !== undefined) {
      const component = __iflet_2;
      lines.push("using Minimact;".join(""));
      lines.push("using System;".join(""));
      lines.push("using System.Collections.Generic;".join(""));
      lines.push("".join(""));
      lines.push("namespace Generated.Components".join(""));
      lines.push("{".join(""));
      lines.push("    [MinimactComponent]".join(""));
      lines.push(`    public class ${component.name} : MinimactComponent`);
      lines.push("    {".join(""));
      for (const field of component.state_fields) {
        lines.push(`        [UseState(${field.initial_value})]`);
        lines.push(`        private ${field.csharp_type} ${field.name};`);
        lines.push("".join(""));
      }
      for (const ref_field of component.ref_fields) {
        lines.push("        [UseRef(null)]".join(""));
        lines.push(`        private ElementRef ${ref_field.name};`);
        lines.push("".join(""));
      }
      for (const effect of component.effect_methods) {
        const deps_str = ((effect.dependencies.length === 0) ? "".join("") : `"${effect.dependencies.join("\", \"")}"`);
        lines.push(`        [UseEffect(${deps_str})]`);
        lines.push(`        private void Effect_${effect.index}()`);
        lines.push("        {".join(""));
        lines.push("            // Effect body would go here".join(""));
        lines.push("        }".join(""));
        lines.push("".join(""));
      }
      lines.push("        protected override VNode Render()".join(""));
      lines.push("        {".join(""));
      const __iflet_3 = component.render_jsx;
      if (__iflet_3 !== null && __iflet_3 !== undefined) {
        const jsx = __iflet_3;
        const vnode_code = Self.jsx_node_to_vnode_code(jsx);
        lines.push(`            return ${vnode_code};`);
      } else {
        lines.push("            return new VElement(\"div\", null, null);".join(""));
      }
      lines.push("        }".join(""));
      lines.push("".join(""));
      for (const method of component.event_methods) {
        lines.push(`        private void ${method.name}()`);
        lines.push("        {".join(""));
        lines.push("            // Method body would go here".join(""));
        lines.push("        }".join(""));
        lines.push("".join(""));
      }
      lines.push("    }".join(""));
      lines.push("}".join(""));
    }
    { csharp: lines.join("\n") };
  }
  
}

module.exports = SimpleCounterTranspiler;
