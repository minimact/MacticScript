// Generated by RustScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP};
use swc_ecma_ast::*;
use swc_ecma_visit::{VisitMut, VisitMutWith};

use swc_ecma_visit::Visit;

#[derive(Debug, Clone)]
pub struct JSXNode {
    pub tag: String,
    pub attributes: Vec<JSXAttr>,
    pub children: Vec<JSXChild>,
}

#[derive(Debug, Clone)]
pub struct JSXAttr {
    pub name: String,
    pub value: String,
}

#[derive(Debug, Clone)]
pub struct ComponentInfo {
    pub name: String,
    pub state_fields: Vec<StateField>,
    pub ref_fields: Vec<RefField>,
    pub effect_methods: Vec<EffectMethod>,
    pub event_methods: Vec<EventMethod>,
    pub render_jsx: Option<JSXNode>,
}

#[derive(Debug, Clone)]
pub struct StateField {
    pub name: String,
    pub initial_value: String,
    pub csharp_type: String,
}

#[derive(Debug, Clone)]
pub struct RefField {
    pub name: String,
}

#[derive(Debug, Clone)]
pub struct EffectMethod {
    pub index: Number,
    pub dependencies: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct EventMethod {
    pub name: String,
}

#[derive(Debug, Clone)]
pub struct State {
    pub current_component: Option<ComponentInfo>,
}

#[derive(Debug, Clone)]
pub struct TranspilerOutput {
    pub csharp: String,
}

pub struct SimpleCounterTranspiler {
    output: String,
    indent_level: usize,
}

impl SimpleCounterTranspiler {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }
    
    fn append(&mut self, s: &str) {
        self.output.push_str(s);
    }
    
    fn newline(&mut self) {
        self.output.push('\n');
    }
    
    fn indent(&mut self) {
        self.indent_level += 1;
    }
    
    fn dedent(&mut self) {
        self.indent_level -= 1;
    }
    
    pub fn finish(self) -> String {
        self.output
    }
    
    fn init() -> State {
        State { current_component: None }
    }
    
    fn capitalize_first(s: &Str) -> String {
        let mut chars = s.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => first.to_uppercase().chain(chars).collect(),
        }
    }
    
    fn expr_to_csharp_value(expr: &Expr) -> String {
        match expr {
            NumericLiteral(n) => n.value.to_string(),
            StringLiteral(s) => format!("\"{}\"", s.value),
            BooleanLiteral(b) => if b.value {             "true".to_string();
 } else {             "false".to_string();
 },
            NullLiteral(_) => "null".to_string(),
            Identifier(id) => id.name.clone(),
            _ => "null".to_string(),
        }
    }
    
    fn infer_csharp_type_from_expr(expr: &Expr) -> String {
        match expr {
            NumericLiteral(n) => {
                if (n.value == n.value.floor()) {
                    "int".to_string()
                } else {
                    "double".to_string()
                }
            },
            StringLiteral(_) => "string".to_string(),
            BooleanLiteral(_) => "bool".to_string(),
            ArrayExpression(_) => "List<dynamic>".to_string(),
            ObjectExpression(_) => "Dictionary<string, dynamic>".to_string(),
            _ => "dynamic".to_string(),
        }
    }
    
    fn extract_jsx_node(jsx: &JSXElement) -> JSXNode {
        let tag = match &jsx.opening_element.name { Identifier(id) => id.name.clone(), _ => "div".to_string(), };
        let mut attributes = vec![];
        for attr in &jsx.opening_element.attributes {
            if matches!(attr, JSXAttribute(_)) {
                let attr_name = match &attr.name { Identifier(id) => id.name.clone(), _ => continue, };
                let attr_value = if &attr.value {                 match val {
                    StringLiteral(s) => s.value.clone(),
                    JSXExpressionContainer(container) => {
                        if matches!(container.expression, Expression(_)) {
                            let expr = &container.expression;
                            format!("{{expr:{}}}", Self::expr_to_csharp_value(expr))
                        } else {
                            String::new()
                        }
                    },
                    _ => String::new(),
                }
 } else {                 "true".to_string();
 };
                attributes.push(JSXAttr { name: attr_name, value: attr_value })
            }
        }
        let mut children = vec![];
        for child in &jsx.children {
            match child {
                JSXElement(elem) => {
                    children.push(JSXChild::Element(Self::extract_jsx_node(elem)))
                },
                JSXText(text) => {
                    let trimmed = text.value.trim();
                    if !trimmed.is_empty() {
                        children.push(JSXChild::Text(trimmed.to_string()))
                    }
                },
                JSXExpressionContainer(container) => {
                    if matches!(container.expression, Expression(_)) {
                        let expr = &container.expression;
                        let expr_str = Self::expr_to_csharp_value(expr);
                        children.push(JSXChild::Expression(expr_str))
                    }
                },
                _ => {
                },
            }
        }
        JSXNode { tag: tag, attributes: attributes, children: children }
    }
    
    fn jsx_node_to_vnode_code(node: &JSXNode) -> String {
        let mut attrs_code = vec![];
        for attr in &node.attributes {
            let value_code = if attr.value.starts_with("{expr:") {             attr.value.trim_start_matches("{expr:").trim_end_matches("}").to_string();
 } else {             format!("\"{}\"", attr.value);
 };
            attrs_code.push(format!("                [\"{}\"] = {}", attr.name, value_code))
        }
        let mut children_code = vec![];
        for child in &node.children {
            match child {
                Element(elem) => {
                    children_code.push(Self::jsx_node_to_vnode_code(elem))
                },
                Text(text) => {
                    children_code.push(format!("\"{}\"", text))
                },
                Expression(expr) => {
                    children_code.push(format!("$\"{{{}}}\"", expr))
                },
            }
        }
        let mut result = format!("new VElement(\"{}\", ", node.tag);
        if (attrs_code.is_empty() && children_code.is_empty()) {
            result.push_str("null, null)")
        } else {
            if attrs_code.is_empty() {
                result.push_str("null, ");
                if (children_code.len() == 1) {
                    result.push_str(&children_code[0])
                } else {
                    result.push_str("new VNode[]
            {
                ");
                    result.push_str(&children_code.join(",
                "));
                    result.push_str("
            }")
                }
                result.push(")")
            } else {
                result.push_str("new Dictionary<string, string>
            {
");
                result.push_str(&attrs_code.join(",
"));
                result.push_str("
            }, ");
                if (children_code.len() == 0) {
                    result.push_str("null")
                } else {
                    if (children_code.len() == 1) {
                        result.push_str(&children_code[0])
                    } else {
                        result.push_str("new VNode[]
            {
                ");
                        result.push_str(&children_code.join(",
                "));
                        result.push_str("
            }")
                    }
                }
                result.push(")")
            }
        }
        result
    }
    
    fn finish(self: &Self) -> TranspilerOutput {
        let mut lines = vec![];
        if let Some(component) = &self.current_component {
            lines.push("using Minimact;".to_string());
            lines.push("using System;".to_string());
            lines.push("using System.Collections.Generic;".to_string());
            lines.push("".to_string());
            lines.push("namespace Generated.Components".to_string());
            lines.push("{".to_string());
            lines.push("    [MinimactComponent]".to_string());
            lines.push(format!("    public class {} : MinimactComponent", component.name));
            lines.push("    {".to_string());
            for field in &component.state_fields {
                lines.push(format!("        [UseState({})]", field.initial_value));
                lines.push(format!("        private {} {};", field.csharp_type, field.name));
                lines.push("".to_string())
            }
            for ref_field in &component.ref_fields {
                lines.push("        [UseRef(null)]".to_string());
                lines.push(format!("        private ElementRef {};", ref_field.name));
                lines.push("".to_string())
            }
            for effect in &component.effect_methods {
                let deps_str = if effect.dependencies.is_empty() {                 "".to_string();
 } else {                 format!("\"{}\"", effect.dependencies.join("\", \""));
 };
                lines.push(format!("        [UseEffect({})]", deps_str));
                lines.push(format!("        private void Effect_{}()", effect.index));
                lines.push("        {".to_string());
                lines.push("            // Effect body would go here".to_string());
                lines.push("        }".to_string());
                lines.push("".to_string())
            }
            lines.push("        protected override VNode Render()".to_string());
            lines.push("        {".to_string());
            if let Some(jsx) = &component.render_jsx {
                let vnode_code = Self::jsx_node_to_vnode_code(jsx);
                lines.push(format!("            return {};", vnode_code))
            } else {
                lines.push("            return new VElement(\"div\", null, null);".to_string())
            }
            lines.push("        }".to_string());
            lines.push("".to_string());
            for method in &component.event_methods {
                lines.push(format!("        private void {}()", method.name));
                lines.push("        {".to_string());
                lines.push("            // Method body would go here".to_string());
                lines.push("        }".to_string());
                lines.push("".to_string())
            }
            lines.push("    }".to_string());
            lines.push("}".to_string())
        }
        TranspilerOutput { csharp: lines.join("
") }
    }
}

impl Visit for SimpleCounterTranspiler {
    
    fn visit_mut_fn_decl(&mut self, n: &FnDecl) {
        let component_name = if &node.id {         id.name.clone();
 } else {         return;
 };
        if !component_name.chars().next().unwrap().is_uppercase() {
            return;
        }
        let mut component = ComponentInfo { name: component_name, state_fields: vec![], ref_fields: vec![], effect_methods: vec![], event_methods: vec![], render_jsx: None };
        if let Some(body) = &node.body {
            let mut effect_counter = 0;
            let mut jsx_node = None;
            let mut __visitor = __InlineVisitor_0 {
                component: &mut component,
                effect_counter: &mut effect_counter,
                jsx_node: &mut jsx_node,
            };
            body.visit_mut_with(&mut __visitor);
            component = ComponentInfo { name: component.name.clone(), state_fields: component.state_fields.clone(), ref_fields: component.ref_fields.clone(), effect_methods: component.effect_methods.clone(), event_methods: component.event_methods.clone(), render_jsx: jsx_node }
        }
        self = State { current_component: Some(component) }
    }
}

// Hoisted inline visitors for traverse blocks
struct __InlineVisitor_0<'a> {
    component: &'a mut i32,
    effect_counter: &'a mut i32,
    jsx_node: &'a mut Option<JSXNode>,
}

impl<'a> VisitMut for __InlineVisitor_0<'a> {
    fn visit_mut_variable_declarator(&mut self, decl: &mut VariableDeclarator) {
        if let Some(init) = &decl.init {
            if matches!(init, CallExpression(_)) {
                let call = init;
                if matches!(call.callee, Identifier(_)) {
                    let callee_name = { let __callee = &call.callee; match __callee { Callee::Expr(e) => match e.as_ref() { Expr::Ident(i) => i.sym.clone(), _ => "".into() }, _ => "".into() } }.clone();
                    if (callee_name == "useState") {
                        if matches!(decl.id, ArrayPattern(_)) {
                            let arr = &decl.id;
                            if (arr.elements.len() >= 1) {
                                if let Some(Identifier(state_id)) = &arr.elements[0] {
                                    let state_name = state_id.name.clone();
                                    let initial_val = if (call.arguments.len() > 0) {                                     Self::expr_to_csharp_value(&call.arguments[0]);
 } else {                                     "null".to_string();
 };
                                    let csharp_type = if (call.arguments.len() > 0) {                                     Self::infer_csharp_type_from_expr(&call.arguments[0]);
 } else {                                     "dynamic".to_string();
 };
                                    self.component.state_fields.push(StateField { name: state_name, initial_value: initial_val, csharp_type: csharp_type })
                                }
                            }
                        }
                    } else {
                        if (callee_name == "useRef") {
                            if matches!(decl.id, Identifier(_)) {
                                let ref_name = decl.id.name.clone();
                                self.component.ref_fields.push(RefField { name: ref_name })
                            }
                        } else {
                            if (callee_name == "useEffect") {
                                let mut deps = vec![];
                                if (call.arguments.len() > 1) {
                                    if matches!(call.arguments[1], ArrayExpression(_)) {
                                        let arr = &call.arguments[1];
                                        for elem in &arr.elements {
                                            if let Some(Identifier(dep_id)) = elem {
                                                deps.push(dep_id.name.clone())
                                            }
                                        }
                                    }
                                }
                                self.component.effect_methods.push(EffectMethod { index: self.effect_counter, dependencies: deps });
                                self.effect_counter += 1
                            }
                        }
                    }
                }
            }
        }
    }
    fn visit_mut_function_declaration(&mut self, func: &mut FnDecl) {
        if let Some(id) = &func.id {
            let method_name = Self::capitalize_first(&id.name);
            self.component.event_methods.push(EventMethod { name: method_name })
        }
    }
    fn visit_mut_return_statement(&mut self, ret: &mut ReturnStmt) {
        if let Some(arg) = &ret.argument {
            if matches!(arg, JSXElement(_)) {
                let jsx_elem = arg;
                self.jsx_node = Some(Self::extract_jsx_node(jsx_elem))
            }
        }
    }
}

