// Generated by RustScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP};
use swc_ecma_ast::*;
use swc_ecma_visit::{VisitMut, VisitMutWith};

//! Generated by RustScript compiler
//! Do not edit manually

#[derive(Debug, Clone)]
pub enum ExpressionTemplate {
    MethodCall(MethodCallTemplate),
    BinaryExpression(BinaryExpressionTemplate),
    MemberExpression(MemberExpressionTemplate),
    UnaryExpression(UnaryExpressionTemplate),
}

fn extract_expression_template(expr: &Expr, component: &Component, path: &String) -> Option<ExpressionTemplate> {
    match expr {
        Identifier(_) => None,
        ConditionalExpression(_) | LogicalExpression(_) => None,
        CallExpression(ref call_expr) => {
            if let MemberExpression(_) = &call_expr.callee {
                if let Some(template) = extract_method_call_template(call_expr, component, path) {
                    return Some(ExpressionTemplate::MethodCall(template));
                }
            }
            None
        },
        BinaryExpression(ref bin_expr) => {
            if let Some(template) = extract_binary_expression_template(bin_expr, component, path) {
                Some(ExpressionTemplate::BinaryExpression(template))
            } else {
                None
            }
        },
        MemberExpression(ref member_expr) => {
            if let Some(template) = extract_member_expression_template(member_expr, component, path) {
                Some(ExpressionTemplate::MemberExpression(template))
            } else {
                None
            }
        },
        UnaryExpression(ref unary_expr) => {
            if let Some(template) = extract_unary_expression_template(unary_expr, component, path) {
                Some(ExpressionTemplate::UnaryExpression(template))
            } else {
                None
            }
        },
        _ => None,
    }
}

